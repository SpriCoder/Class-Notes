Java 方法
---

<!-- TOC -->

- [1. 命名法](#1-命名法)
- [2. 方法的所有属性](#2-方法的所有属性)
- [3. 方法的意义](#3-方法的意义)
- [4. 接口](#4-接口)
- [5. 运行期：](#5-运行期)
- [6. 可见性：](#6-可见性)
- [7. 成员方法的声明](#7-成员方法的声明)
- [8. 成员方法的调用机制](#8-成员方法的调用机制)
- [9. 方法的结构](#9-方法的结构)
  - [9.1. 顺序](#91-顺序)
  - [9.2. 选择](#92-选择)
  - [9.3. 循环](#93-循环)
- [10. 返回值：](#10-返回值)
- [11. 方法重载与方法重写](#11-方法重载与方法重写)
  - [11.1. 方法重写(Override)](#111-方法重写override)
  - [11.2. 方法重载(Overload)](#112-方法重载overload)
  - [11.3. 重写和重载的区别](#113-重写和重载的区别)
- [12. 方法调用的字节码](#12-方法调用的字节码)
  - [12.1. 方法的调用](#121-方法的调用)
  - [12.2. overloading优先级](#122-overloading优先级)

<!-- /TOC -->

1. 方法的概念：
   + 物理角度：指令块
   + 逻辑角度：抽象指令单元
   + 语义角度：行为
2. 分类：
   + 类的行为：方法
   + 对象的行为：方法

# 1. 命名法
1. 第一个字母小写，之后的首字母大写。
2. 一般用动词，或者动宾短语
3. 和boolean相关的，isValid

# 2. 方法的所有属性
1. 类的行为：
   1. 静态方法
   2. 类名来调用
2. 对象的行为：
   1. 成员方法
   2. 对象的引用来调用

# 3. 方法的意义
1. 逻辑封装
2. 重用
3. 可修改性

# 4. 接口
+ 返回值
+ 方法名
+ 参数
   + 个数
   + 类型
   + 顺序
+ 抛出的异常

# 5. 运行期：
+ 程序执行的时间段
+ 方法调用
   + 同步
      + 调用的方法和被调用的方法相关
      1. 每个方法只有一个入口。
      2. 被调用方法执行时，调用方法停止
      3. 调用结束后，程序控制权交换
   + 异步
      + 调用方法和被调用方法不相关

# 6. 可见性：
   + public
   + private
   + protected
   + 缺省（在一个包中）
# 7. 成员方法的声明
修饰词 返回类型 方法名称（参数列表){  
   方法  
}  

# 8. 成员方法的调用机制
1. 方法被同步调用的特性
   1. 每个方法都只有一个入口
   2. 当执行被调用的方法的时候，调用方法暂停
   3. 当方法结束时，程序的控制权交还给调用处
2. 封装和闭包

# 9. 方法的结构
1. 接口中的方法可以重载，但需要实现全部方法，也就是接口继承时
## 9.1. 顺序

## 9.2. 选择
1. if
2. if else
3. switch(c)
4. switch(string)

## 9.3. 循环
1. while
2. do while
3. for 
4. for each syntax
5. 特殊的关键字
   1. break
   2. continue
   3. return
   4. exit:
      返回0:返回正常值
      返回-1：程序异常跳出
# 10. 返回值：  
`return`返回值  
`exit`退出程序运行，返回0，正常，-1，错误退出

# 11. 方法重载与方法重写

## 11.1. 方法重写(Override)
1. 重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变
2. 好处在于：子类可以根据需要特定于自己的行为
3. 重写方法不能抛出新的检查异常或者比重写方法申明更加宽泛异常重写的方法要求被
4. 要求原来的父类中必须有这个方法
5. 方法的重写规则：
   1. 参数列表必须完全与被重写方法的相同
   2. 返回类型可以与被重写方法的类型不相同，但是必须是父类返回值的派生类
   3. 访问权限不能比父类中重写的方法的访问权限更低。`public<protected`
   4. 父类的成员方法只能被它的子类重写
   5. 声明为final的方法不能被重写
   6. 声明为static的方法不能被重写，但是可以被再次声明
   7. 子类可以重写父类的方法：
      1. 子类和父类同包时，可以重写所有除了声明为private和final的方法
      2. 子类和父类不同包时，那么子类只能重写父类声明为public和protected的非final方法
   8. 构造方法不能被重写
   9. 如果不能继承一个方法，则不能重写这个方法
   10. 重写方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常
      + 不能抛出新的
      + 不能抛出更广泛的
```java
class programmer(){
    programmer game(){return this;};
}
class NJUCoder extends programmer{
    int game(){return 1;}//编译错误，不能有不同返回值的
}
```

## 11.2. 方法重载(Overload)
1. 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
2. 最常用的是构造器的重载
3. 每个重载的方法必须有独一无二的参数类型列表
4. 特点：
   + 变量类型
   + 变量数量
   + **在同一个类内的不同的方法，只不过恰好名字相同。**
   + 非法重载：
      1. 只有标识符不同
      2. 只有返回值不同
5. 代码重载规则：
   1. 被重载的方法必须改变参数列表(参数数量或者类型不一样)
   2. 被重载的方法可以改变返回类型
   3. 被重载的方法可以改变访问修饰符
   4. 被重载方法可以声明新的或更广的检查异常
   5. 方法能够在同一类中或者在一个子类中被重载
   6. 无法以返回值类型作为重载函数的区分标准

## 11.3. 重写和重载的区别

区别点|重载方法|重写方法
-|-|-
参数列表|必须修改|一定不能修改
返回类型|可以修改|一定不能修改
异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常
访问|可以修改|一定不能做更严格的限制


# 12. 方法调用的字节码

## 12.1. 方法的调用
1. invokestatic:静态方法调用
2. invokespecial:实例构造器的`<init>`方法，私有方法和父类方法
3. invokevirtual:虚方法
4. invokeinterface:接口方法，会在运行时再确定一个实现此接口的对象
5. invokedynamic:会在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户有更高的自由度

## 12.2. overloading优先级
1. char>int>long>character>serializable>object>char...